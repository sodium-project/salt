if(NOT DEFINED SALT_DEBUG_STD_COMPATIBILITY)
    set(SALT_DEBUG_STD_COMPATIBILITY OFF)
endif()

function(salt_debug_message)
    if(SALT_DEBUG_STD_COMPATIBILITY)
        message("${ARGV}")
    endif()
endfunction()

# This function will return the alignment of the C++ type specified in
# <_TYPE>, the result will be in <_OUT>.
function(salt_get_type_alignments _TYPE _OUT)
    file(WRITE "${CMAKE_BINARY_DIR}/generated/std_compatibility/align_of.cpp"
    [[#include <cstddef>
template <typename T, std::size_t alignment> requires(0u == alignment)
struct align_of {};
template <typename T>
using get_align_of = align_of<T, alignof(T) >;
using long_long    = long long;
using long_double  = long double;
get_align_of<TEST_TYPE> alignment;
]])

    # Compilation should fail - the purpose of this is to generate a compile error of a type
    # "align_of<type, value>" that is the alignment of the specified type.
    try_compile(
        compile_result_unused
        ${CMAKE_BINARY_DIR}
        ${CMAKE_BINARY_DIR}/generated/std_compatibility/align_of.cpp
        COMPILE_DEFINITIONS "-DTEST_TYPE=${_TYPE}"
        OUTPUT_VARIABLE _ALIGNMENT_OUTPUT
        CXX_STANDARD 20
        CXX_STANDARD_REQUIRED TRUE
    )
    # Parse the align_of<..., ##> in the compiler error output.
    # string(REGEX MATCH "align_of<.*,[ ]*([0-9]+)[ul ]*>" _ALIGNMENT_MATCHED ${_ALIGNMENT_OUTPUT})
    string(REGEX MATCH "'?align_of'? [\[].*[,|; ]([0-9]+)\]" _ALIGNMENT_MATCHED ${_ALIGNMENT_OUTPUT})

    if(_ALIGNMENT_MATCHED)
        set(${_OUT} ${CMAKE_MATCH_1} PARENT_SCOPE)
    else()
        message(FATAL_ERROR
            "Unable to determine alignment of C++ type ${_TYPE} - no text matching align_of<..., ##> in compiler error output")
    endif()
endfunction()

# This function will return a list of C++ types with unique alignment
# values, covering all possible alignments supported by the currently
# configured C++ compiler.
function(salt_get_unique_alignments _TYPES_OUT _ALIGNMENTS_OUT)
    set(_UNIQUE_ALIGNMENTS)
    set(_UNIQUE_TYPES)

    set(_ALL_TYPES char bool short int long long_long float double long_double)
    foreach(TYPE IN LISTS _ALL_TYPES)
        salt_get_type_alignments("${TYPE}" ALIGNMENT)
        salt_debug_message("Alignment of '${TYPE}' is '${ALIGNMENT}'")

        if(NOT ${ALIGNMENT} IN_LIST _UNIQUE_ALIGNMENTS)
            list(APPEND _UNIQUE_ALIGNMENTS ${ALIGNMENT})
            list(APPEND _UNIQUE_TYPES ${TYPE})
        endif()
    endforeach()

    set(${_TYPES_OUT} ${_UNIQUE_TYPES} PARENT_SCOPE)
    set(${_ALIGNMENTS_OUT} ${_UNIQUE_ALIGNMENTS} PARENT_SCOPE)
endfunction()

# This function is used by `salt_configure_containers`.
# Don't call it unless you know what you are doing.
function(salt_configure_containers_hpp _HEADER_OUT)
    set(_HEADER ${CMAKE_BINARY_DIR}/generated/std_compatibility/containers_node_size_impl.hpp.in)

    file(WRITE "${_HEADER}"
    [[// The following section was autogenerated by container_node_sizes.cmake
//=== BEGIN AUTOGENERATED SECTION ===//
@CONTAINERS_CONTENT@
//=== END AUTOGENERATED SECTION ===//
]])

    set(${_HEADER_OUT} ${_HEADER} PARENT_SCOPE)
endfunction()

# This function is used by `salt_get_container_node_size`.
# Don't call it unless you know what you are doing.
function(salt_configure_containers_cpp _SOURCE_OUT)
    set(_SOURCE ${CMAKE_BINARY_DIR}/generated/std_compatibility/containers_node_size_impl.cpp)

    file(WRITE "${_SOURCE}"
    [[#include <cstddef>
#include <tuple>

#if FORWARD_LIST_CONTAINER
#include <forward_list>
#endif
#if LIST_CONTAINER
#include <list>
#endif
#if MAP_CONTAINER || MULTIMAP_CONTAINER
#include <map>
#endif
#if SHARED_PTR_STATELESS_CONTAINER || SHARED_PTR_STATEFUL_CONTAINER
#include <memory>
#endif
#if SET_CONTAINER || MULTISET_CONTAINER
#include <set>
#endif
#if UNORDERED_MAP_CONTAINER || UNORDERED_MULTIMAP_CONTAINER
#include <unordered_map>
#endif
#if UNORDERED_SET_CONTAINER || UNORDERED_MULTISET_CONTAINER
#include <unordered_set>
#endif

struct empty {};

template <typename T, typename U>
struct is_same       { static constexpr bool value = false; };
template <typename T>
struct is_same<T, T> { static constexpr bool value = true;  };

template <typename T, typename U>
constexpr bool is_not_same = not is_same<T, U>::value and (sizeof(T) != sizeof(U));

template <
    std::size_t alignment,
    std::size_t size,
    bool        is_node_type = false
>
struct node_size {
    static_assert(!is_node_type, "Expected to fail");
};

template <typename T, typename State = empty, bool get_size = true, typename InitialType = T>
struct dummy_allocator :
    public  node_size<alignof(InitialType),
                      sizeof(T) - (get_size ? sizeof(InitialType) : 0),
                      is_not_same<InitialType, T>>,
    private State
{
    using value_type = T;

    T*     allocate(std::size_t);
    void deallocate(T*, std::size_t);

    template <typename U>
    struct rebind {
        using other = dummy_allocator<U, State, get_size, InitialType>;
    };
};

struct dummy_hash {
    // NOTE: Not `noexcept`! This leads to a cached hash value.
    template <typename T>
    std::size_t operator()(T const&) const { return 0; }
};

#if FORWARD_LIST_CONTAINER
template <typename T>
int test_container() {
    std::forward_list<T, dummy_allocator<T>> list = {T()};
    return 0;
}
#endif // FORWARD_LIST_CONTAINER

#if LIST_CONTAINER
template <typename T>
int test_container() {
    std::list<T, dummy_allocator<T>> list = {T()};
    return 0;
}
#endif // LIST_CONTAINER

#if SET_CONTAINER
template <typename T>
int test_container() {
    std::set<T, std::less<T>, dummy_allocator<T>> set = {T()};
    return 0;
}
#endif // SET_CONTAINER

#if MULTISET_CONTAINER
template <typename T>
int test_container() {
    std::multiset<T, std::less<T>, dummy_allocator<T>> set = {T()};
    return 0;
}
#endif // MULTISET_CONTAINER

#if UNORDERED_SET_CONTAINER
template <typename T>
int test_container() {
    std::unordered_set<T, dummy_hash, std::equal_to<T>, dummy_allocator<T>> set = {T()};
    return 0;
}
#endif // UNORDERED_SET_CONTAINER

#if UNORDERED_MULTISET_CONTAINER
template <typename T>
int test_container() {
    std::unordered_multiset<T, dummy_hash, std::equal_to<T>, dummy_allocator<T>> set = {T()};
    return 0;
}
#endif // UNORDERED_MULTISET_CONTAINER

#if MAP_CONTAINER
template <typename T>
int test_container() {
    using type = std::pair<T const, T>;
    std::map<T, T, std::less<T>, dummy_allocator<type>> map = {{T(),T()}};
    return 0;
}
#endif // MAP_CONTAINER

#if MULTIMAP_CONTAINER
template <typename T>
int test_container() {
    using type = std::pair<T const, T>;
    std::multimap<T, T, std::less<T>, dummy_allocator<type>> map = {{T(),T()}};
    return 0;
}
#endif // MULTIMAP_CONTAINER

#if UNORDERED_MAP_CONTAINER
template <typename T>
int test_container() {
    using type = std::pair<T const, T>;
    std::unordered_map<T, T, dummy_hash, std::equal_to<T>, dummy_allocator<type>> map = {{T(),T()}};
    return 0;
}
#endif // UNORDERED_MAP_CONTAINER

#if UNORDERED_MULTIMAP_CONTAINER
template <typename T>
int test_container() {
    using type = std::pair<T const, T>;
    std::unordered_multimap<T, T, dummy_hash, std::equal_to<T>, dummy_allocator<type>> map = {{T(),T()}};
    return 0;
}
#endif // UNORDERED_MULTIMAP_CONTAINER

#if SHARED_PTR_STATELESS_CONTAINER
template <typename T>
int test_container() {
    auto ptr = std::allocate_shared<T>(dummy_allocator<T, empty, false>());
    return 0;
}
#endif // SHARED_PTR_STATELESS_CONTAINER

#if SHARED_PTR_STATEFUL_CONTAINER
template <typename T>
int test_container() {
    struct allocator_reference_payload { void* ptr; };
    
    auto ptr = std::allocate_shared<T>(dummy_allocator<T, allocator_reference_payload, false>());
    return 0;
}
#endif // SHARED_PTR_STATEFUL_CONTAINER

using long_long   = long long;
using long_double = long double;

#ifdef TEST_TYPES
template <typename... Types>
int test_all(std::tuple<Types...>) {
    int dummy[] = {(test_container<Types>())...};
    return 0;
}

int foo = test_all(std::tuple<TEST_TYPES>());
#endif

#ifdef TEST_TYPE
int foo = test_container<TEST_TYPE>();
#endif
]])

    set(${_SOURCE_OUT} ${_SOURCE} PARENT_SCOPE)
endfunction()

# This function will return node sizes for the requested container
# when created with the specified set of types.
function(salt_get_container_node_size _CONTAINER _TYPES _ALIGNMENTS_OUT _NODE_SIZES_OUT)
    set(_ALIGNMENTS)
    set(_NODE_SIZES)

    foreach(TYPE IN LISTS _TYPES)
        salt_configure_containers_cpp(_CONTAINERS_SOURCE_PATH)

        # Compilation should fail - the purpose of this is to generate a compile error of a type
        # "node_size<type_size, node_size, is_node_type> that is the node size of the specified container.
        try_compile(
            compile_result_unused
            ${CMAKE_BINARY_DIR}
            ${_CONTAINERS_SOURCE_PATH}
            COMPILE_DEFINITIONS "-D${_CONTAINER}=1" "-DTEST_TYPE=${TYPE}"
            OUTPUT_VARIABLE _CONTAINERS_OUTPUT
            CXX_STANDARD 20
            CXX_STANDARD_REQUIRED TRUE
        )

        if(NOT _CONTAINERS_OUTPUT)
	        message(FATAL_ERROR
                    "Unable to determine node size of C++ container ${_CONTAINER} holding type ${TYPE}"
                    "${_CONTAINERS_OUTPUT}")
        endif()
        # Parse the node_size<##, ##, true> in the compiler error output.
        string(
            REGEX MATCH "node_size<[ ]*([0-9]+)[ul ]*,[ ]*([0-9]+)[ul ]*,[ ]*true[ ]*>"
            _CONTAINERS_NODE_SIZE_MATCHED
            ${_CONTAINERS_OUTPUT})

        if(_CONTAINERS_NODE_SIZE_MATCHED)
            # Extract the alignment and node size
            if(NOT ${CMAKE_MATCH_1} IN_LIST _ALIGNMENTS)
                list(APPEND _ALIGNMENTS ${CMAKE_MATCH_1})
                list(APPEND _NODE_SIZES ${CMAKE_MATCH_2})
            endif()
        else()
            message(FATAL_ERROR
                    "Unable to determine node size of C++ container ${_CONTAINER} holding type ${TYPE}"
                    "${_CONTAINERS_OUTPUT}")
        endif()
    endforeach()

    set(${_ALIGNMENTS_OUT} ${_ALIGNMENTS} PARENT_SCOPE)
    set(${_NODE_SIZES_OUT} ${_NODE_SIZES} PARENT_SCOPE)
endfunction()

# This function will write the containers node size to an output header
# file that can be used to calculate the node size of a container holding
# the specified type.
function(salt_configure_containers _FILE_OUT)
    message(STATUS "Getting container node sizes...")

    salt_configure_containers_hpp(_CONTAINERS_HEADER_PATH)

    # Build up the file contents in the variable `CONTAINERS_CONTENT`,
    # as requested in containers_node_size_impl.hpp.in
    set(CONTAINERS_CONTENT "")

    # Get the set of uniquely aligned types to work with
    salt_get_unique_alignments(_TYPES _ALIGNMENTS)
    salt_debug_message("=> alignments <${_ALIGNMENTS}> types <${_TYPES}>")

    set(_CONTAINER_TYPES
        forward_list list
        set multiset unordered_set unordered_multiset
        map multimap unordered_map unordered_multimap
        shared_ptr_stateless shared_ptr_stateful
	)

    string(APPEND CONTAINERS_CONTENT "\

#include <type_traits>
#include <cstddef>")
    foreach(CONTAINER IN LISTS _CONTAINER_TYPES)
        string(TOUPPER "${CONTAINER}_container" _CONTAINER_NAME)
        salt_get_container_node_size("${_CONTAINER_NAME}" "${_TYPES}" _ALIGNMENTS _NODE_SIZES)
        salt_debug_message(
                "Node size [container = ${_CONTAINER_NAME} types = <${_TYPES}>, alignments = ${_ALIGNMENTS}, node sizes = ${_NODE_SIZES}]")

        # Generate the contents for this container type
	    string(APPEND CONTAINERS_CONTENT "\

namespace detail {

template <std::size_t Alignment>
struct [[nodiscard]] ${CONTAINER}_node_size_impl;
")

        list(LENGTH _ALIGNMENTS _N_ALIGNMENTS)
        math(EXPR _LAST_ALIGNMENT "${_N_ALIGNMENTS}-1")
        foreach(INDEX RANGE ${_LAST_ALIGNMENT})
            list(GET _ALIGNMENTS ${INDEX} ALIGNMENT)
            list(GET _NODE_SIZES ${INDEX} NODE_SIZE)

            # Generate content for this alignment/node size in this container
            string(APPEND CONTAINERS_CONTENT "\

template <>
struct [[nodiscard]] ${CONTAINER}_node_size_impl<${ALIGNMENT}>
: std::integral_constant<std::size_t, ${NODE_SIZE}>
{};
")
        endforeach()

        # End contents for this container type
        string(APPEND CONTAINERS_CONTENT "\

} // namespace detail

template <typename T>
struct [[nodiscard]] ${CONTAINER}_node_size
: std::integral_constant<std::size_t,
       detail::${CONTAINER}_node_size_impl<alignof(T)>::value + sizeof(T)>
{};
")
    endforeach()

    salt_debug_message("Configuring file: ${_FILE_OUT}")

    # Finally, write the file. As a reminder, configure_file() will
    # substitute in any CMake variables wrapped in @VAR@ in the inpout
    # file and write them to the output file; and will only rewrite
    # the file and update its timestamp if the contents have changed.
    # The only variable that will be substituted is CONTAINERS_CONTENT
    configure_file("${_CONTAINERS_HEADER_PATH}" ${_FILE_OUT})
endfunction()

# code: language='CMake' insertSpaces=true tabSize=4
